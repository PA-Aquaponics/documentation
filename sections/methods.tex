\documentclass[../main.tex]{subfiles}

\begin{document}
	\section{Vorgehen / Methoden}
	
	\subsection{Swagger}
	Erste Umsetzungen finden mithilfe eines Swaggerprojekts statt. Hier kann ein Entwurf erstellt werden. Mithilfe dieses Entwurfs wird ein Grundgerüst hergestellt, welcher dazu dient, vereinfacht die REST Schnittstelle zu bauen.
	
	\begin{figure}[h]
		\centering
		\includegraphics[scale=0.4]{Swagger}
		\caption{Swagger Beispiel}
		\label{fig:Swagger}
	\end{figure}
	
	Die Schnittstelle soll dazu fähig sein Daten der Sensoren zurückzugeben. Die Möglichkeit soll bestehen, dass die Sensorendaten zusätzlich editierbar sind.
	
	Als Vereinfachung können die Sensoren auch als eine Liste angezeigt werden.
	
	\subsection{Continuous Integration}
	Als Source Control wird Git eingesetzt und um mit allen Entwicklern zusammen zu arbeiten befindet sich das Repository auch auf github.com. Github bietet uns mit den Github Actions ein gutes Tool welches wir automatisch das gesamte Spring-Boot Projekt erstellen, testen und auf DockerHub hochladen können. Die Github Actions werden bei jedem Push in den Main Branch angestossen. In den Main Branch wird in der Regel nur dann gepusht wenn ein Feature Branch nach Pull Request und Code Review in den Main gemergerd wird. Daher wird das Github Actions nicht bei jedem Commit ausgeführt und nur funktionierende Versionen werden auf Dockerhub hochgeladen.
	
	\subsection{Docker}
	Docker kann sehr vielfältig eingesetzt werden, aber worin Docker seine stärken hat ist im Deployment. Mit einem gutem Docker-Compose File ist ein komplexes Multi-Container System mit einem Befehl aufgesetzt.
	
	\subsubsection{Docker-Image}
	Von unserer Spring-Boot Applikation erstellen wir ein Image welches auf DockerHub hochgeladen wird. Von der Datenbank erstellen wir kein Image da DockerHub wie Github öffentlich zugänglich ist und wir die Datenbank nicht veröffentlichen wollen. Die Datenbank wird dann beim erstellen des MySQL Containers eingelesen wie im nächsten Abschnitt erklärt.
	
	\subsubsection{Docker-Compose}
	Das Docker-Compose holt sich die neuste Version der Applikation und erstellt ein Netzwerk für das Gesamte PAAQ-System. Der Applikation wird ein Portforwarding eingerichtet, dass diese auch von Aussen zugänglich ist. Anschliessend wird auch ein MySQL-Container heruntergeladen und in das gleiche Netzwerk eingehängt, dass eine Kommunikation zwischen Spring-Boot Applikation und MySQL-Datenbank statt finden kann. Der MySQL Datenbank wird noch der Dump der alten Datenbank mitgegeben, dass eine exakte Kopie der vorherigen Datenbank erstellt.
	\begin{lstlisting}[language=yaml]
		version: "3.3"
		
		services:
		  mysqldb:
		    image: mysql:latest
		    container_name: mysqldb_aquaponics
		    restart: unless-stopped
		    environment:
		      - MYSQL_ROOT_PASSWORD=[MYSQL_ROOT_PASSWORD]
		      - MYSQL_DATABASE=[MYSQL_DATABASE]
		    ports:
		      - "3306"
		    volumes:
		      - /home/[user]/dump:/docker-entrypoint-initdb.d
		      
		  spring_boot:
		    image: [dockerhub_username]/paaq:latest
		    container_name: spring_boot_aquaponics
		    restart: on-failure
		    ports:
		      # map port 8080 on host to 8080 on container
		      - "8080:8080"
	\end{lstlisting}
\end{document}